# Feature Specification: Authentication System and JWT Integration

**Feature Branch**: `003-better-auth-jwt`
**Created**: 2026-01-13
**Status**: Draft
**Input**: User description: "Authentication System and JWT Integration using Better Auth and FastAPI"

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Backend Verifies JWT and Enforces User Isolation (Priority: P1)

As a backend developer, I need FastAPI middleware to verify JWT tokens on every protected request and automatically extract the authenticated user_id, so that all database queries are automatically scoped to the authenticated user, preventing unauthorized access to other users' data.

**Why this priority**: This is the security foundation that prevents unauthorized data access. Without this, the entire authentication system is ineffective and users could access each other's data. This is a NON-NEGOTIABLE security requirement per the constitution.

**Independent Test**: Can be fully tested by sending requests with valid JWTs, invalid JWTs, and missing JWTs to protected endpoints. Verify that valid tokens pass through with extracted user_id, invalid tokens return 401, and database queries automatically filter by the authenticated user_id. Delivers complete backend security layer.

**Acceptance Scenarios**:

1. **Given** a protected FastAPI endpoint exists, **When** a request arrives with a valid JWT in the Authorization header, **Then** the middleware extracts the user_id from the token and allows the request to proceed
2. **Given** a protected endpoint exists, **When** a request arrives without an Authorization header, **Then** the middleware returns 401 Unauthorized with error message "Missing authentication token"
3. **Given** a protected endpoint exists, **When** a request arrives with an invalid or expired JWT, **Then** the middleware returns 401 Unauthorized with error message "Invalid or expired token"
4. **Given** an authenticated request with user_id=5, **When** the request queries the database for todos, **Then** the query automatically includes "WHERE user_id = 5" filter
5. **Given** an authenticated request with user_id=5, **When** the request attempts to access a todo with user_id=10, **Then** the system returns 404 Not Found (not 403, to prevent enumeration attacks)

---

### User Story 2 - Frontend Integrates Better Auth with JWT Plugin (Priority: P1)

As a frontend developer, I need Next.js pages to use Better Auth client with JWT authentication plugin, so that users can sign up, sign in, and have their JWT tokens automatically managed and included in API requests to the FastAPI backend.

**Why this priority**: Without frontend authentication UI and token management, users cannot authenticate and access the protected backend API. This is required for the application to function.

**Independent Test**: Can be fully tested by rendering sign-up and sign-in forms, submitting credentials, verifying JWT tokens are stored and sent with subsequent API requests, and verifying logout clears tokens. Delivers complete frontend authentication flow.

**Acceptance Scenarios**:

1. **Given** a user visits the sign-up page, **When** they enter valid email and password and submit, **Then** Better Auth creates a user account and returns a JWT token that is stored in the browser
2. **Given** a user visits the sign-in page, **When** they enter correct credentials, **Then** Better Auth verifies credentials and returns a JWT token that is stored
3. **Given** an authenticated user makes an API request to the backend, **When** the request is sent, **Then** the JWT token is automatically included in the Authorization header as "Bearer {token}"
4. **Given** an authenticated user clicks logout, **When** the logout action completes, **Then** the JWT token is removed from browser storage and the user is redirected to the sign-in page
5. **Given** a JWT token is expired, **When** the user tries to access a protected page, **Then** the frontend redirects to sign-in page with message "Session expired, please sign in again"

---

### User Story 3 - System Shares JWT Secret Between Frontend and Backend (Priority: P1)

As a system administrator, I need both the Next.js frontend (Better Auth) and FastAPI backend to use the same JWT secret from environment variables, so that tokens generated by Better Auth can be verified by FastAPI middleware, enabling secure cross-service authentication.

**Why this priority**: Without a shared secret, the backend cannot verify tokens generated by the frontend, making authentication impossible. This is the cryptographic foundation that binds the two services.

**Independent Test**: Can be fully tested by setting JWT_SECRET in both .env files, having Better Auth generate a token, and verifying FastAPI can decode it successfully. Test with mismatched secrets to verify rejection. Delivers cryptographic trust chain.

**Acceptance Scenarios**:

1. **Given** JWT_SECRET="shared-secret-123" is set in both frontend and backend .env files, **When** Better Auth generates a JWT token, **Then** FastAPI middleware can successfully decode and verify the token
2. **Given** the JWT_SECRET is different between frontend and backend, **When** a token generated by Better Auth is sent to FastAPI, **Then** FastAPI returns 401 Unauthorized with error "Invalid token signature"
3. **Given** JWT_SECRET is missing from backend .env, **When** the backend application starts, **Then** it logs a clear error "JWT_SECRET environment variable not set" and refuses to start
4. **Given** JWT_SECRET is missing from frontend .env, **When** Better Auth tries to initialize, **Then** it logs a clear error message and refuses to generate tokens
5. **Given** JWT_SECRET is rotated (changed), **When** existing tokens are used, **Then** they are rejected with 401 Unauthorized, forcing users to sign in again with the new secret

---

## Functional Requirements *(mandatory)*

### Authentication Core (P1)

**FR-001**: Backend MUST verify JWT token signature on every protected endpoint using shared JWT_SECRET
- **Input**: JWT token from Authorization header
- **Output**: Decoded user_id or 401 error
- **Constraints**: Token expiration checked, algorithm validated (HS256 only)

**FR-002**: Backend MUST extract user_id from JWT claims and make it available to all route handlers
- **Input**: Verified JWT token
- **Output**: Request context with authenticated user_id
- **Constraints**: user_id must be positive integer, cannot be null

**FR-003**: All database queries for user-owned resources MUST automatically filter by authenticated user_id
- **Input**: Database query + authenticated user_id
- **Output**: Query results scoped to user_id
- **Constraints**: No queries should ever return data from other users

**FR-004**: Frontend MUST use Better Auth client with JWT plugin for all authentication operations
- **Input**: User credentials (email, password)
- **Output**: JWT token stored in browser
- **Constraints**: Token auto-refreshed on expiry, secure storage required

### Token Management (P1)

**FR-005**: JWT tokens MUST include claims: user_id, email, iat (issued at), exp (expiration)
- **Input**: User authentication event
- **Output**: Signed JWT with standard claims
- **Constraints**: Expiration set to 24 hours, user_id must match database record

**FR-006**: Frontend MUST automatically include JWT token in Authorization header for all API requests
- **Input**: Any fetch/axios request to backend
- **Output**: Request with "Authorization: Bearer {token}" header
- **Constraints**: Only include token for same-origin requests

**FR-007**: Backend MUST reject tokens with invalid signatures, expired timestamps, or missing claims
- **Input**: Invalid JWT token
- **Output**: 401 Unauthorized with specific error message
- **Constraints**: No partial acceptance, fail-closed security model

### Configuration (P1)

**FR-008**: Both services MUST load JWT_SECRET from environment variables, not hardcoded values
- **Input**: .env file or system environment
- **Output**: Loaded JWT_SECRET used for signing/verification
- **Constraints**: Minimum 32 characters, fail startup if missing

**FR-009**: Backend MUST document required environment variables in .env.example with security warnings
- **Input**: None
- **Output**: Template file with JWT_SECRET placeholder
- **Constraints**: Must include warning about secret rotation and production security

### User Isolation (P1 - NON-NEGOTIABLE)

**FR-010**: Every protected endpoint MUST implement user_id filtering at the database query level
- **Input**: Authenticated request + database query
- **Output**: Results filtered to current user only
- **Constraints**: Middleware provides user_id, queries use SQLAlchemy where clause

**FR-011**: Attempts to access other users' resources MUST return 404 Not Found (not 403 Forbidden)
- **Input**: Request for resource belonging to different user_id
- **Output**: 404 error response
- **Constraints**: Prevents resource enumeration attacks

**FR-012**: Database foreign key constraints MUST enforce user_id integrity
- **Input**: Any write operation creating user-owned resources
- **Output**: Record with valid user_id foreign key
- **Constraints**: Foreign key to users table, ON DELETE CASCADE

---

## Success Criteria *(mandatory)*

**SC-001**: Complete Authentication Flow
- User can sign up with email/password on frontend
- User can sign in and receive JWT token
- Token is automatically included in backend requests
- User can access protected resources
- User can log out and token is cleared

**SC-002**: Backend Security Layer
- FastAPI middleware verifies JWT on all protected endpoints
- Invalid tokens return 401 Unauthorized with clear error messages
- Valid tokens extract user_id and provide it to route handlers
- All database queries automatically filter by user_id

**SC-003**: User Data Isolation
- User A cannot access User B's todos (returns 404)
- User A cannot modify User B's todos
- Database queries automatically include WHERE user_id = authenticated_user filter
- Enumeration attacks prevented (404 not 403)

**SC-004**: Shared Secret Configuration
- Both services load JWT_SECRET from .env
- Tokens signed by Better Auth can be verified by FastAPI
- Mismatched secrets result in 401 errors
- Missing secrets prevent application startup with clear error

**SC-005**: Token Lifecycle Management
- Tokens expire after configured duration (24 hours)
- Expired tokens rejected with 401
- Frontend detects expiration and redirects to sign-in
- No token refresh mechanism in MVP (requires re-authentication)

**SC-006**: Error Handling
- Missing Authorization header: 401 "Missing authentication token"
- Invalid token signature: 401 "Invalid or expired token"
- Expired token: 401 "Invalid or expired token"
- Missing JWT_SECRET: Application fails to start with clear error
- All errors logged with request context

**SC-007**: Documentation and Examples
- .env.example files for both services with JWT_SECRET template
- Backend middleware implementation documented
- Frontend Better Auth setup documented
- Example API requests showing Authorization header usage

---

## Assumptions *(mandatory)*

1. **Better Auth JWT Plugin Available**: Better Auth library has JWT authentication plugin that can be configured with a shared secret
2. **Email/Password Only**: MVP uses email and password authentication only, no OAuth providers
3. **No Token Refresh**: Users must sign in again after token expiration (no refresh token mechanism in MVP)
4. **Same-Origin Only**: Frontend and backend run on same domain or CORS is properly configured
5. **HTTPS in Production**: Production deployment uses HTTPS to protect JWT tokens in transit
6. **User Table Exists**: Database schema includes users table with id (primary key), email (unique), and hashed_password fields (from feature 001-db-schema)
7. **Password Hashing**: Better Auth handles password hashing automatically (bcrypt or similar)
8. **Single JWT Secret**: One shared secret is sufficient for MVP, no key rotation mechanism yet

---

## Out of Scope *(mandatory)*

**Explicitly NOT included in this feature**:

1. **OAuth Providers**: Google, GitHub, Facebook login - only email/password in MVP
2. **Password Reset Flow**: Forgot password / reset password functionality
3. **Email Verification**: User email confirmation after sign-up
4. **Token Refresh Mechanism**: Automatic token renewal without re-authentication
5. **Multi-Factor Authentication (MFA)**: SMS, authenticator app, or backup codes
6. **Session Management**: Server-side session storage, active session tracking
7. **Role-Based Access Control (RBAC)**: Admin vs regular user permissions
8. **Rate Limiting**: Brute force protection, login attempt throttling
9. **Account Lockout**: Temporary account suspension after failed login attempts
10. **JWT Key Rotation**: Automated secret rotation or multiple valid secrets
11. **User Profile Management**: Update email, change password endpoints
12. **Audit Logging**: Detailed authentication event logging beyond basic security logs

These features may be added in future iterations but are not part of the initial authentication implementation.

---

## Edge Cases *(mandatory)*

1. **Token Tampering**: If user modifies JWT payload (changes user_id), signature verification fails, middleware returns 401, request rejected
2. **Clock Skew**: If frontend and backend system clocks differ significantly (>5 minutes), token expiration checks may fail incorrectly - solution: use NTP time synchronization in production
3. **Token Sent to Wrong Backend**: If JWT token generated for one environment (dev) is sent to another (staging), signature verification fails due to different JWT_SECRET values
4. **Concurrent Requests with Expired Token**: Multiple requests sent simultaneously with just-expired token all return 401, frontend detects and redirects to sign-in once
5. **User Deleted But Token Valid**: If user account is deleted while their JWT is still valid, backend queries return empty results (user_id not found), treated as 404 for all requests
6. **Missing user_id in Token**: If Better Auth misconfiguration results in JWT without user_id claim, middleware returns 401 "Invalid token claims"
7. **SQL Injection via user_id**: SQLAlchemy parameterized queries used throughout, user_id from JWT cannot be used for injection attacks