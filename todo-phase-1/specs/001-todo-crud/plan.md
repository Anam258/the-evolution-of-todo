# Implementation Plan: Phase I Todo CRUD

**Branch**: `001-todo-crud` | **Date**: 2025-12-30 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `specs/001-todo-crud/spec.md`

## Summary

Phase I implements an in-memory Python console application for todo task management with full CRUD operations (Create, Read, Update, Delete) plus completion status tracking. The application runs in a menu-driven loop, stores all data in memory (no persistence), and provides clear user feedback for all operations. Architecture is designed to support Phase II migration to SQLite/cloud storage while maintaining current simplicity requirements.

**Technical Approach**: Clean modular Python structure with separation of concerns - Task domain model, TaskManager service layer for business logic, CLI handlers for user interaction, and main loop orchestrator. Dictionary-based in-memory storage enables O(1) task lookups while preserving sequential ID generation.

## Technical Context

**Language/Version**: Python 3.11+
**Primary Dependencies**: None (stdlib only for Phase I simplicity)
**Storage**: In-memory dictionary (task_id → Task object mapping)
**Testing**: Manual validation via quickstart guide (tests not requested in spec)
**Target Platform**: WSL 2 Ubuntu (Linux environment on Windows)
**Project Type**: Single console application
**Performance Goals**: <1 second response time for up to 100 tasks, <2 second startup
**Constraints**: No persistence, no external dependencies, console-only interface
**Scale/Scope**: Single-user, 50-100 tasks in memory, session-scoped data

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### I. Spec-Driven Development ✅ PASS
- Specification complete and approved ([spec.md](spec.md))
- Planning phase in progress (this document)
- Tasks will be generated from approved plan
- Implementation will reference Task IDs in commits

### II. Agent-Generated Code Only ✅ PASS
- All production code will be generated via Claude Code
- No manual coding allowed per NFR-006
- Human review and approval only

### III. Windows Development via WSL 2 ✅ PASS
- Development environment: WSL 2 Ubuntu
- Python 3.11+ execution in Linux environment
- Documented in quickstart.md setup section

### IV. Phase-Based Evolution ✅ PASS
- Phase I architecture decisions support Phase II-V evolution:
  - **Task model** uses dataclass (easily converts to ORM model)
  - **TaskManager** abstraction isolates storage logic (swap in-memory → SQLite → PostgreSQL)
  - **Sequential ID generation** pattern compatible with database auto-increment
  - **Input validation** layer prepares for API input sanitization
  - **Error handling** structure supports HTTP status codes in Phase II
- ADR-001 will document storage evolution path

### V. User Story Independence ✅ PASS
- Spec defines 4 independent, prioritized user stories (P1-P3)
- Each story deliverable independently per tasks.md phases
- P1 (Create/View) provides standalone MVP value

### VI. Test-Driven Development ✅ PASS (NOT REQUIRED)
- Tests NOT requested in specification
- Manual validation via quickstart guide sufficient for Phase I
- Future phases may add automated testing

### VII. Simplicity and YAGNI ✅ PASS
- **No external dependencies** (stdlib only)
- **No ORM/framework** (premature for in-memory storage)
- **No CLI library** (simple input() loop sufficient)
- **No config files** (no configuration needed)
- **Dictionary storage** (simplest O(1) lookup structure)
- All complexity justified in Complexity Tracking section below

### VIII. Observability and Debuggability ✅ PASS
- stdin/stdout for all I/O (input() and print())
- Errors to stderr via print(..., file=sys.stderr)
- No JSON output mode (not required in Phase I spec, defer to Phase II API)
- Clear error messages per FR-007 and NFR-004

### IX. Version Control and Traceability ✅ PASS
- Feature branch: 001-todo-crud
- Commits will reference Task IDs from tasks.md
- User story mapping in task descriptions

**Constitution Compliance**: 9/9 principles passing. Ready for planning.

## Project Structure

### Documentation (this feature)

```text
specs/001-todo-crud/
├── spec.md              # Feature specification (complete)
├── plan.md              # This file
├── research.md          # Phase 0: Codebase research (not applicable, greenfield project)
├── data-model.md        # Phase 1: Task entity and storage design
├── quickstart.md        # Phase 1: User setup and usage guide
└── tasks.md             # Phase 2: Implementation task breakdown (generated by /sp.tasks)
```

### Source Code (repository root)

```text
src/
├── models/
│   └── task.py          # Task dataclass with id, title, description, is_complete
├── services/
│   └── task_manager.py  # TaskManager class: CRUD operations, in-memory storage
├── cli/
│   ├── handlers.py      # Menu option handlers (create, view, update, delete, complete)
│   └── display.py       # UI formatting functions (menu, task list, messages)
└── main.py              # Application entry point, main loop, menu orchestration

tests/                   # Reserved for future phases (no tests in Phase I)
├── unit/                # Future: Unit tests for models and services
├── integration/         # Future: End-to-end CLI workflow tests
└── contract/            # Future: Task model schema validation

docs/                    # Reserved for project-wide documentation
└── adrs/                # Architectural Decision Records
    └── 001-in-memory-to-sqlite-evolution.md  # Storage migration strategy

README.md                # Project overview, WSL 2 setup, quickstart link
setup.sh                 # One-command project initialization (Python venv, verify version)
requirements.txt         # Empty for Phase I (no external dependencies)
.gitignore               # Python standard ignores (venv, __pycache__, *.pyc)
```

**Structure Decision**: Single project layout chosen because:
- Phase I is a standalone console application (no frontend/backend split)
- All code fits in src/ with clear separation: models, services, cli, main
- Simple hierarchy supports Phase II evolution (add api/ for REST endpoints, migrate storage to db/)
- Follows Python standard practices (src layout, tests sibling to src)

## Complexity Tracking

**No violations** - All decisions align with Simplicity principle (YAGNI):

| Decision | Justification | Simpler Alternative Rejected |
|----------|---------------|------------------------------|
| Dictionary storage (not list) | O(1) task lookup by ID vs O(n) linear search; required for FR-007 (validate task existence before operations) | List with linear search: unacceptable performance degradation at 50-100 tasks |
| TaskManager service layer | Isolates storage logic from CLI handlers; enables Phase II storage swap without touching UI code | Direct manipulation in handlers: violates Phase IV evolution requirement (Phase II requires storage abstraction) |
| Dataclass for Task model | Type hints + immutability patterns prepare for ORM migration; clear schema for Phase II database | Plain dict: loses type safety and schema definition needed for Phase II SQLite migration |

**Note**: All three "complexity" additions are **required** for Phase I functional requirements (FR-007 performance) and Phase IV evolution readiness. No unnecessary abstractions added.

## Phase 0: Research

**Status**: Not applicable (greenfield project, no existing codebase)

**Research Questions** (addressed via constitution and spec review):
1. **Storage approach for Phase I→II migration**: Dictionary (in-memory) → SQLite (file) → PostgreSQL (cloud)
   - **Finding**: Dataclass pattern mirrors ORM model structure; TaskManager abstraction enables storage swap
2. **ID generation strategy**: Sequential integer IDs starting from 1, never reused
   - **Finding**: Track `next_id` counter in TaskManager; compatible with database auto-increment
3. **Error handling patterns**: Return tuple (success: bool, message: str) from service methods
   - **Finding**: Enables clear user feedback (FR-007) and prepares for HTTP status codes (Phase II)
4. **Input validation approach**: Validate at CLI handler layer before calling service methods
   - **Finding**: Prevents invalid data from reaching business logic; prepares for API input sanitization

**Research artifacts**: None (no existing code to analyze)

## Phase 1: Design

### Data Model

See [data-model.md](data-model.md) for complete entity definitions and relationships.

**Summary**:
- **Task entity**: id (int), title (str), description (str), is_complete (bool)
- **Storage structure**: `Dict[int, Task]` for O(1) lookups
- **ID generation**: Sequential counter starting from 1
- **Validation rules**: Title non-empty, ID positive integer

### CLI Flow

See [quickstart.md](quickstart.md) for user interaction examples.

**Menu Structure**:
```
=== Todo App ===
1. Create Task
2. View All Tasks
3. Update Task
4. Delete Task
5. Mark Task Complete
6. Mark Task Incomplete
7. Exit

Enter choice (1-7):
```

**Interaction Pattern** (per menu option):
1. User selects menu number
2. System prompts for required inputs (ID, title, description)
3. System validates inputs and executes operation
4. System displays success/error message
5. System returns to main menu (loop continues)
6. Exit option (7) terminates loop

**Error Handling**:
- Invalid menu choice → "Invalid choice. Please enter 1-7."
- Non-numeric ID input → "Invalid task ID format. Please enter a number."
- Task ID not found → "Task ID {id} does not exist."
- Empty title → "Title cannot be empty. Please try again."
- All errors return to main menu (no crashes per NFR-003)

### Module Responsibilities

**src/models/task.py**:
- Define Task dataclass with type hints
- Provide `__str__` method for human-readable display
- Encapsulate task data (no business logic)

**src/services/task_manager.py**:
- Maintain in-memory storage (`Dict[int, Task]`)
- Track next_id counter for sequential ID generation
- Implement CRUD methods: create, get_all, get_by_id, update, delete, toggle_complete
- Return (success, message) tuples for error handling
- Validate task existence for update/delete/complete operations

**src/cli/handlers.py**:
- Implement handler functions for each menu option
- Prompt user for inputs (title, description, task ID)
- Validate input format (non-empty title, numeric ID)
- Call TaskManager methods and display results
- Handle errors and show user-friendly messages

**src/cli/display.py**:
- Format and display main menu
- Format task list (ID, title, completion status)
- Display success/error messages with consistent styling
- Helper functions: print_menu(), print_tasks(), print_message()

**src/main.py**:
- Initialize TaskManager instance
- Display startup message (warn about in-memory data loss)
- Run main loop: display menu → get choice → route to handler → repeat
- Handle exit condition (choice == 7)
- Entry point: `if __name__ == "__main__":`

## Architectural Decisions

### ADR-001: In-Memory to SQLite Evolution Path

**Status**: Proposed
**Context**: Phase I uses in-memory storage; Phase II requires SQLite; Phase III+ requires PostgreSQL.
**Decision**: Use dictionary storage with TaskManager abstraction to enable zero-UI-change storage migration.

**Details**: See `docs/adrs/001-in-memory-to-sqlite-evolution.md` (to be created)

**Summary**:
- **Phase I**: `TaskManager` stores `Dict[int, Task]` in memory
- **Phase II**: Replace `TaskManager` internals with SQLite via sqlite3 (stdlib)
- **Phase III+**: Replace SQLite with PostgreSQL via psycopg2 or ORM (e.g., SQLAlchemy)
- **CLI handlers unchanged** across all phases (depend only on TaskManager interface)

**Trade-offs**:
- ✅ Enables storage evolution without UI rewrite
- ✅ Demonstrates architectural foresight to hackathon judges
- ⚠️ Adds one layer of indirection (acceptable per Complexity Tracking)

### ADR-002: No External Dependencies (Phase I)

**Status**: Accepted
**Context**: Constitution mandates simplicity; no CLI framework or ORM needed for 100-task in-memory app.
**Decision**: Use Python stdlib only (no requirements.txt dependencies).

**Rationale**:
- **No CLI library** (click, typer): Simple input() loop sufficient for 7 menu options
- **No ORM** (SQLAlchemy, Peewee): Premature abstraction for in-memory dict storage
- **No validation library** (pydantic): Dataclass + manual checks adequate for 4 Task fields
- **Defer dependencies to Phase II** when complexity justifies them (SQLite ORM, API framework)

**Trade-offs**:
- ✅ Zero setup friction (no pip install, works anywhere with Python 3.11+)
- ✅ Fast startup (<1 second per NFR-001)
- ⚠️ Manual input validation (acceptable for simple console app)

## Phase I Implementation Strategy

Implementation will follow user story priorities (P1 → P2 → P3):

### Milestone 1: MVP (P1 - Create and View Tasks)
- Implement Task model
- Implement TaskManager with create() and get_all()
- Implement CLI handlers for options 1 (Create) and 2 (View)
- Implement main loop with partial menu
- **Deliverable**: User can create and view tasks (standalone MVP)

### Milestone 2: Completion Tracking (P2)
- Add toggle_complete() to TaskManager
- Implement CLI handlers for options 5 (Complete) and 6 (Incomplete)
- Update View handler to display completion status
- **Deliverable**: User can mark tasks complete/incomplete

### Milestone 3: Full CRUD (P3)
- Add update() and delete() to TaskManager
- Implement CLI handlers for options 3 (Update) and 4 (Delete)
- **Deliverable**: Full feature set per specification

### Milestone 4: Polish
- Add startup warning about data loss
- Validate all edge cases (empty title, invalid IDs, 100+ tasks)
- Finalize error messages per NFR-004
- **Deliverable**: Production-ready Phase I application

## Dependencies & Blockers

**No external blockers** - All dependencies available in Python 3.11+ stdlib.

**Prerequisites**:
- Python 3.11+ installed in WSL 2 (documented in quickstart.md)
- Git for version control (already configured per repository structure)

**Phase Dependencies**:
- **Phase 0 (Research)**: N/A (greenfield)
- **Phase 1 (Design)**: Complete (this document + data-model.md + quickstart.md)
- **Phase 2 (Tasks)**: Depends on user approval of this plan
- **Phase 3 (Implementation)**: Depends on approved tasks.md

## Next Steps

1. **User approval** of this plan (constitution gate)
2. Create **data-model.md** (Task entity details, validation rules, storage structure)
3. Create **quickstart.md** (WSL 2 setup, run instructions, usage examples)
4. Create **ADR-001** (storage evolution strategy)
5. Generate **tasks.md** via `/sp.tasks` command
6. Await task approval before implementation

**Ready for**: `/sp.tasks` command after user approves plan and supporting docs.
